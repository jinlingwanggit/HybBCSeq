#!/usr/bin/python

# Kam Hon Hoi
# 10/31/2017

# Purpose: To clean up the demultiplexed file and identifying the variable domains and put them in the correct frame
#
# Usage: python NintySix-barcode-cleanup.py -h

from argparse import ArgumentParser
import json
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
from numpy import prod
from optimized_pwm import PWM
import os
from multiprocessing import cpu_count
from pebble import ProcessPool
from itertools import izip

# Arguments handler
parser=ArgumentParser()
parser.add_argument("motif",type=str,help="The motifT file corresponding to the species of the sequences")
parser.add_argument("infile",type=str,help="The CSV file generated by NintySix-barcode.py script")
args=parser.parse_args()

# Extracting filename
filename=args.infile[:-10]

#--Supporting Functions--#
# Function that converts MotifT to variables
def convertMotifTable2Var(inputjson):
	with open(inputjson) as f:
		lines=[f.next() for i in range(8)]
		lpos=[int(i) for i in json.loads(lines[0])]
		rpos=[int(i) for i in json.loads(lines[1])]
		lmotif=json.loads(lines[2])
		rmotif=json.loads(lines[3])
		lcommotif=json.loads(lines[4])
		rcommotif=json.loads(lines[5])
		pattern=lcommotif+'.*'+rcommotif
		lwlen=int(lpos[-1])
		rwlen=int(rpos[-1])
		maxlpos=json.loads(lines[6])
		maxrpos=json.loads(lines[7])
	return lmotif,rmotif

# This function finds the stretch of sequence surrounded by the motifs
def FindFv(inargs):
	# initialization
	seq=inargs[0]
	LMotif=inargs[1]
	RMotif=inargs[2]
	MaxP=1e-99*1e-99
	fvnt=seq
	vrfnt=seq
	lmotiflen=int(sorted([int(k) for k in LMotif])[-1])
	rmotiflen=int(sorted([int(k) for k in RMotif])[-1])
	isAb=False

	# scanning for best left flank
	[bestLstart,bestLend,Lframe,LMaxP]=PWM(seq,LMotif)

	# scanning for best right flank
	[bestRstart,bestRend,Rframe,RMaxP]=PWM(seq,RMotif)

	# storing scoreset
	scoreset=(LMaxP*RMaxP,bestLstart,bestRend,Lframe,Rframe)

	# checking for best possible sequence for reporting
	if LMaxP*RMaxP > 1e-60 and LMaxP*RMaxP > MaxP and Lframe==Rframe:
		MaxP=LMaxP*RMaxP
		bestscoreset=scoreset
		if Lframe>=3:
			seq=str(Seq(seq,generic_dna).reverse_complement())
		fvnt=seq[scoreset[1]:scoreset[2]]
		vrfnt=seq[scoreset[1]-30:scoreset[2]+31]
		isAb=True
	if len(fvnt)<20:
		fvnt=seq
	return fvnt,vrfnt,isAb


# Main program #
argslist=[]
lineholder=[]
if __name__=="__main__":
	#Processing input and using multiprocessing on function FindFv
	with open(args.infile,"r") as f, open("%s-cleaned.csv"%filename,"w") as fout:
		[lmotif,rmotif]=convertMotifTable2Var(args.motif)
		for line in f:
			line=line.strip()
			if 'Well' in line:
				header=line.split("\t")
				header=','.join(header)
				print >>fout,"%s"%header
				continue
			tmp=line.split(",")
			tmplist=(tmp[6],lmotif,rmotif)
			argslist.append(tmplist)
			lineholder.append(tmp)
		
		completedcnt=0
		with ProcessPool(max_workers=cpu_count(), max_tasks=10000) as pool:
			results=pool.map(FindFv,argslist,timeout=60)
			for i,result in izip(range(len(lineholder)),results.result()):
				seq=result[0]
				vrfseq=result[1]
				isAb=result[2]
				tmp=lineholder[i]
				aaseq=str(Seq(seq,generic_dna).translate()) # Added this to check for frame shift stop codon 
				if isAb and len(seq)>300:
					line=','.join(tmp[:6])+','+seq
					if tmp[0]=='I13':
						print >>foutcontrol,"%s"%','.join(tmp)
					elif '*' not in aaseq:
						print >>fout,"%s"%line
				completedcnt+=1

			print "Completed %d"%completedcnt
